@using ExpenseTracker.Models.Services
@using ExpenseTracker.Models
@inject IJSRuntime JS
@inject GetItemService GetItemService
@inject AuthenticationStateProvider AuthenticationStateProvider


<h3 class="Expense_title" style="margin-bottom:20px">Expense List (@_startDate?.ToString("dd/MM/yyyy") - @_endDate?.ToString("dd/MM/yyyy"))</h3>
<!-- Need to fix the layout responsivesness for flexbox in smaller screens-->
<div class="Expense_filterbar" style="display:flex; gap:50px ; margin-bottom:10px">
    <div class="Expense_filterbar_buttons">
        <button class="btn btn-outline-primary me-2" @onclick="FilterToday">Today</button>
        <button class="btn btn-outline-primary me-2" @onclick="FilterMonthly">Monthly</button>
        <button class="btn btn-outline-primary" @onclick="FilterYearly">Yearly</button>
    </div>
    <div class="Date_input_div" style="display:flex; gap:10px">
        <InputDate @bind-Value="StartDate" class="form-control"  style="width:50%"/>
        <InputDate @bind-Value="EndDate" class="form-control" style="width:50%" />
    </div>

</div>


<div class="row">
    <div class="col-md-6">
        <div id="myChart" style="width:100%; height:400px;"></div>
    </div>
    <div class="col-md-6">
        <div id="myBarChart" style="width:100%; height:400px;"></div>
    </div>
</div>
<br />
<p>@(filteredExpenses == null || !filteredExpenses.Any() ? "You have 0 expenses added" : $"Expenses count: {filteredExpenses.Count}")</p>

@if (filteredExpenses == null || !filteredExpenses.Any())
{
    <p>No expenses found</p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Title</th>
                <th>Description</th>
                <th>Amount</th>
                <th>Category</th>
                <th>Date</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var expense in filteredExpenses)
            {
                <tr>
                    <td>@expense.Title</td>
                    <td>@expense.Description</td>
                    <td>@($"{expense.Amount}{expense.Currency}")</td>
                    <td>@expense.Category</td>
                    <td>@expense.Date.ToLocalTime().ToString("dd/MM/yyyy HH:mm")</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private List<Expense>? expenses;
    private List<Expense> filteredExpenses = new();
    private string selectedFilter = "SelectedDates";  //Default dates when entering page is Monthly  view of starting from 1st  to 30-31st. Initialized below in _endDate & _startDate properties
    private bool shouldRenderCharts = false;


    //Load the initial Expense datea on page reload
    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            var userId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;

            if (!string.IsNullOrEmpty(userId))
            {
                expenses = await GetItemService.GetUserExpensesAsync(userId);
                filteredExpenses = GetFilteredExpenses();
                shouldRenderCharts = true;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldRenderCharts && expenses != null)
        {
            await RenderChartsAsync();

            shouldRenderCharts = false; // prevent infinite rerender
        }
    }

    //Fill the charts with filtered by using IJSRuntime
    private async Task RenderChartsAsync()
    {
        var chartData = filteredExpenses
            .GroupBy(e => e.Category)
            .Select(g => new
            {
                category = g.Key,
                amount = g.Sum(e => e.Amount)
            }).ToList();

        await JS.InvokeVoidAsync("renderExpenseChart", "myChart", chartData);
        await JS.InvokeVoidAsync("renderExpenseBarChart", "myBarChart", chartData);
    }

    //Filtering
    /******************************************************************************************/

    private void FilterToday()
    {
        StartDate = DateTime.Now.Date;
        EndDate = DateTime.Now.Date;
    }

    private void FilterMonthly()
    {
        var today = DateTime.Now.Date;
        // Set start date to the first day of this month
        StartDate = new DateTime(today.Year, today.Month, 1);

        // Calculate the number of days in this month to get the last day
        int lastDay = DateTime.DaysInMonth(today.Year, today.Month);
        EndDate = new DateTime(today.Year, today.Month, lastDay);
    }

    private void FilterYearly()
    {
        var today = DateTime.Now;

        StartDate = new DateTime(today.Year, 1, 1); // January 1st
        EndDate = new DateTime(today.Year, 12, 31, 23, 59, 59); // December 31st, end of day
    }


    private async Task ChangeFilter(string mode)
    {
        selectedFilter = mode;
        filteredExpenses = GetFilteredExpenses(); 
        await RenderChartsAsync();
    }


    private DateTime? _startDate = new DateTime(DateTime.Now.Date.Year, DateTime.Now.Date.Month, 1);  // Default values basicly copying the Month logic from FilterMonthly()
    private DateTime? _endDate = new DateTime(DateTime.Now.Date.Year, DateTime.Now.Date.Month, DateTime.DaysInMonth(DateTime.Now.Date.Year, DateTime.Now.Date.Month)); // Default values basicly copying the Month logic from FilterMonthly()

    public DateTime? StartDate
    {
        get => _startDate;
        set
        {
            _startDate = value;

            //if startDate is set higher than end date change end date to match startDate
            if (_startDate.HasValue && _endDate.HasValue && _startDate > _endDate)
            {
                _endDate = _startDate;
                SetDataRange();
            }
            else if (_startDate.HasValue && _endDate.HasValue)
                SetDataRange();
        }
    }

    public DateTime? EndDate
    {
        get => _endDate;
        set
        {
            //if startDate is set higher than end date change end date to match startDate
            if (_startDate.HasValue && _endDate.HasValue && value < _startDate.Value)
            {
                _endDate = _startDate;
                SetDataRange();
            }
            else
                SetDataRange();
        }
    }

    private async void SetDataRange()
    {
        if (_startDate.HasValue && _endDate.HasValue)
        {
            await ChangeFilter("SelectedDates");
        }
    }


    // TODO Maybe add Timezone current version can be inaccurate with large timezone changes
    private List<Expense> GetFilteredExpenses()
    {
        if (expenses == null)
        {
            return new List<Expense>();
        }
        List<Expense> filteredExpenses = new List<Expense>();
        if(selectedFilter == "SelectedDates")
        {
            filteredExpenses = expenses
                .Where(e => e.Date.Date >= _startDate && e.Date.Date <= _endDate)
                .ToList();
        }
        else
        {
            filteredExpenses = expenses;
        }
        return filteredExpenses;
    }

}
